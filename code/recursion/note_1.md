属于尾递归形式的算法，均可以简洁地转化为等效的迭代版本

divide-and-conquer:各子问题必须可独立求解，无需借助其他子问题的原始数据或中间结果


---

### 1. **传值（Pass by Value）**
   - 当你传递一个变量给函数时，函数会创建一个新的副本，操作的是这个副本，而不是原始变量。
   - 原始变量的值不会受到影响。

   #### 示例代码：
   ```cpp
   void increment(int x) {
       x = x + 1; // 修改的是副本
   }

   int main() {
       int a = 5;
       increment(a); // 传递的是 a 的值
       cout << a;    // 输出 5，a 的值没有改变
       return 0;
   }
   ```

   #### 类比：
   - 就像你给朋友复印了一本书，朋友在复印件上做笔记，但你的原书不会受到影响。

---

### 2. **传引用（Pass by Reference）**
   - 当你传递一个变量给函数时，函数直接操作原始变量，而不是创建副本。
   - 原始变量的值会被修改。

   #### 示例代码：
   ```cpp
   void increment(int &x) { // x 是引用参数
       x = x + 1; // 修改的是原始变量
   }

   int main() {
       int a = 5;
       increment(a); // 传递的是 a 的引用
       cout << a;   // 输出 6，a 的值被修改
       return 0;
   }
   ```

   #### 类比：
   - 就像你直接把书借给朋友，朋友在书上做笔记，你的原书也会被修改。

---

### 3. **引用参数的作用**
   - 引用参数允许函数直接修改传入的变量。
   - 在递归或需要返回多个值的场景中，引用参数非常有用。

   #### 示例代码：
   ```cpp
   void swap(int &x, int &y) { // x 和 y 是引用参数
       int temp = x;
       x = y;
       y = temp;
   }

   int main() {
       int a = 5, b = 10;
       swap(a, b); // 交换 a 和 b 的值
       cout << a << " " << b; // 输出 10 5
       return 0;
   }
   ```

   #### 类比：
   - 就像你把两个盒子交给朋友，朋友可以直接交换盒子里的东西，而不需要复制盒子。

---

### 4. **回到斐波那契数列的例子**
   - 在 `fib_linear` 函数中，`prev` 是一个引用参数，用于返回当前项的前一项的值。
   - 每次递归调用时，`prev` 的值会被修改，并传递回调用者。

   #### 示例调用：
   ```cpp
   int main() {
       int n = 2;
       long long prev;
       long long result = fib_linear(n, prev);
       cout << "Fibonacci(" << n << ") = " << result << endl; // 输出 1
       cout << "Previous value = " << prev << endl;          // 输出 1
       return 0;
   }
   ```

   #### 解释：
   - `prev` 的值在递归调用中被修改，并传递回调用者。
   - 这就是引用参数的作用：允许函数直接修改传入的变量。

---

### 5. **总结**
   - **传值**：函数操作的是变量的副本，原始变量不受影响。
   - **传引用**：函数直接操作原始变量，原始变量会被修改。
   - **引用参数的作用**：在需要修改传入变量或返回多个值的场景中非常有用。
